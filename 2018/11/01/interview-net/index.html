<!DOCTYPE html>
<html lang="en">
    <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
    <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="赵翰奕在 Github 上的个人博客">
    <meta name="keyword" content="">
    <meta name="theme-color" content="#600090">
    <meta name="msapplication-navbutton-color" content="#600090">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#600090">
    <link rel="shortcut icon" href="https://cdn4.iconfinder.com/data/icons/ionicons/512/icon-person-128.png">
    <link rel="alternate" type="application/atom+xml" title="Angus" href="/atom.xml">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/animate.css/3.5.2/animate.min.css">
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.css">
    <title>
        
        常见面试问题总结（网络）｜Angus&#39;s blog
        
    </title>

    <link rel="canonical" href="http://zhaoangus.github.io/2018/11/01/interview-net/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/blog-style.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">
</head>

<style>

    header.intro-header {
        background-image: url('//o7bkkhiex.bkt.clouddn.com/lion-blur-bg.jpg')
    }
</style>

<script>
    hljs.initHighlightingOnLoad();
</script>
<!-- hack iOS CSS :active style -->
<body ontouchstart="" class="animated fadeIn">
<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top " id="nav-top" data-ispost = "true" data-istags="false
" data-ishome = "false" >
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand animated pulse" href="/">
                <span class="brand-logo">
                    Angus
                </span>
                's Blog
            </a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <!-- /.navbar-collapse -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
					
                    
                        
							
                        <li>
                            <a href="/Tags/">Tags</a>
                        </li>
							
						
                    
					
					
                </ul>
            </div>
        </div>
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
//    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>

<!-- Main Content -->

<!--only post-->


<img class="wechat-title-img"
     src="">


<style>
    
    header.intro-header {
        background-image: url('')
    }

    
</style>

<header class="intro-header">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <div class="post-heading">
                    <h1>常见面试问题总结（网络）</h1>
                    
                    <span class="meta">
                         作者 Zhao Angus
                        <span>
                          日期 2018-11-01
                         </span>
                    </span>
                    <div class="tags text-center">
                        
                        <a class="tag" href="/tags/#Vue"
                           title="Vue">Vue</a>
                        
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="post-title-haojen">
        <span>
            常见面试问题总结（网络）
        </span>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <!-- Post Container -->
            <div class="col-lg-8 col-lg-offset-1 col-sm-9 post-container">
                <h1 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h1><h2 id="从输入一个url到返回数据，发生了什么"><a href="#从输入一个url到返回数据，发生了什么" class="headerlink" title="从输入一个url到返回数据，发生了什么"></a>从输入一个url到返回数据，发生了什么</h2><p>假设在浏览器输入<a href="http://www.baidu.com:80/index.html" target="_blank" rel="noopener">http://www.baidu.com:80/index.html</a>, 假设解析出的ip地址是202.43.78.3</p>
<ol>
<li>浏览器解析出主机名<br>解析出的主机名是<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li>
<li>浏览器查询这个主机名的ip地址（DNS）<br>（1）浏览器启动时，首先浏览器会去操作系统获取dns服务器地址，然后把这个地址缓存下来。同时浏览器还会去读取和解析hosts文件，同样放到缓存中。浏览器对解析过的域名和ip地址，都会保存着这两者的映射关系。（存到cache中）<br>（2）当解析域名的时候，首先浏览器会去cache中查找有没有缓存好的映射关系，如果没有的话，就去hosts文件中查找，如果也没有的话，浏览器就会发起请求去dns服务器缓存查询了，如果缓存里面也没有，那最后就是dns服务器去查询了。</li>
<li>浏览器获取端口号</li>
<li>浏览器向目标ip地址发起一条到202.43.78.3:80的tcp连接<br><strong>三次握手</strong><br>（1）首先浏览器会向服务器发起一个连接请求<br>（2）服务器会对连接请求做出响应，表示同意建立连接<br>（3）浏览器收到响应后，再告知对方，它知道服务器同意它建立连接了。</li>
<li>数据包在ip层传输，通过多台计算机和网络设备中转，在中转时，利用中转设备的mac地址搜索下一个中转目标（采用ARP协议，根据通信方的ip地址就可以反查出对应的mac地址），直到目标ip地址。</li>
<li>数据链路层处理网络连接的硬件部分，比如网卡，找到服务器的网卡</li>
<li>浏览器向服务器发送一条http报文<br>每一条http报文的组成：<br>起始行+首部+主体(可选)<br>起始行：http/1.0 200 ok (一般包括http版本，返回状态码，返回码原因)<br>首部：content-type:text/plain content-length:19<br>主体：name=jane</li>
<li>服务器接受客户端请求，进行一些处理，返回响应报文<br>（1）建立连接，如果接受一个客户端连接，就建立连接，如果不同意，就将其关闭。<br>（2）接收请求，读取http请求报文<br>（3）访问资源，访问报文中指定的资源<br>（4）构建响应，创建带有首部的http响应报文<br>（5）发送响应，将响应回送给客户端</li>
<li>浏览器读取http响应报文</li>
<li>浏览器关闭连接</li>
</ol>
<h2 id="浏览器获得资源后到呈现页面的过程"><a href="#浏览器获得资源后到呈现页面的过程" class="headerlink" title="浏览器获得资源后到呈现页面的过程"></a>浏览器获得资源后到呈现页面的过程</h2><ol>
<li>浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码。</li>
<li>根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)</li>
<li>根据Render Tree渲染网页</li>
</ol>
<h2 id="DNS过程"><a href="#DNS过程" class="headerlink" title="DNS过程"></a>DNS过程</h2><p>浏览器DNS查找顺序一般是这样的：浏览器缓存→系统缓存→路由器缓存→ISP（网络服务提供商）DNS缓存→递归搜索</p>
<h2 id="http特性"><a href="#http特性" class="headerlink" title="http特性"></a>http特性</h2><ol>
<li>http是不保存状态的协议</li>
<li>请求只能从客户端开始。客户端不可以接收除响应以外的指令<br>对于一些实时监控的功能，常常用websocket来代替</li>
<li>没有用户认证，任何人都可以发起请求</li>
<li>通信使用的是明文</li>
<li>无法证明报文完整性</li>
<li>http持久连接和并行连接</li>
</ol>
<h2 id="http请求方法"><a href="#http请求方法" class="headerlink" title="http请求方法"></a>http请求方法</h2><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。<br>使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。<br>例如，/index.jsp?id=100&amp;op=bind,这样通过GET方式传递的参数直接表示在地址中。</p>
<ol>
<li>各个数据之间用”&amp;”符号隔开。很显然，这种方式不适合传送私密数据。</li>
<li>由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。</li>
</ol>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。<br><strong>POST方法是把提交的数据放在HTTP包的request body中</strong>。</p>
<h3 id="GET-POST对比"><a href="#GET-POST对比" class="headerlink" title="GET POST对比"></a>GET POST对比</h3><blockquote>
<p>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</p>
</blockquote>
<h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><p>HEAD就像GET，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。</p>
<h2 id="http请求的header"><a href="#http请求的header" class="headerlink" title="http请求的header"></a>http请求的header</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ol>
<li>Cache-control:用来指定Response-Request遵循的缓存机制。</li>
<li>Pragma:防止页面被缓存。 Pragma: no-cache = Cache-Control:no-cache</li>
</ol>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ol>
<li>Accept:浏览器端可以接受的媒体类型。</li>
<li>Accept-Language</li>
<li>Accept-Encoding</li>
<li>User-Agent:告诉HTTP服务器，客户端使用的操作系统和浏览器的名称和版本。</li>
</ol>
<h3 id="Cookie-Login"><a href="#Cookie-Login" class="headerlink" title="Cookie/Login"></a>Cookie/Login</h3><ol>
<li>Cookie</li>
</ol>
<h3 id="Entity"><a href="#Entity" class="headerlink" title="Entity"></a>Entity</h3><ol>
<li>Content-Length</li>
<li>Content-Type</li>
</ol>
<h3 id="Miscellaneous"><a href="#Miscellaneous" class="headerlink" title="Miscellaneous"></a>Miscellaneous</h3><ol>
<li>Referer:提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。<br>例如: Referer:<a href="http://translate.google.cn/?hl=zh-cn&amp;tab=wT" target="_blank" rel="noopener">http://translate.google.cn/?hl=zh-cn&amp;tab=wT</a></li>
</ol>
<h3 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h3><ol>
<li>Connection:keep-alive/close</li>
<li>Host:请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。</li>
</ol>
<h2 id="响应的状态码"><a href="#响应的状态码" class="headerlink" title="响应的状态码"></a>响应的状态码</h2><p>Response 消息中的第一行叫做状态行，由HTTP协议版本号，状态码，状态消息三部分组成。<br>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别<br>1XX  提示信息 - 表示请求已被成功接收，继续处理<br>2XX  成功 - 表示请求已被成功接收，理解，接受<br>3XX  重定向 - 要完成请求必须进行更进一步的处理<br>4XX  客户端错误 -  请求有语法错误或请求无法实现<br>5XX  服务器端错误 -   服务器未能实现合法的请求 </p>
<p>200 请求成功<br>204 代表响应报文中包含若干首部和一个状态行，但是没有实体的主体内容。主要用于在浏览器不转为显示新文档的情况下，对其进行更新。（页面不会发生跳转）<strong>对于一些提交到服务器处理的数据，只需要返回是否成功的情况下，可以考虑用状态码204来作为返回信息，从而省略多余的数据传输。</strong><br>301 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替<br>304 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源<br>403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求<br>404 请求的资源（网页等）不存在<br>500 内部服务器错误<br>504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求</p>
<h2 id="缓存与304"><a href="#缓存与304" class="headerlink" title="缓存与304"></a>缓存与304</h2><p>浏览器的缓存机制分为两个部分。1、当前缓存是否过期？2、服务器中的文件是否有改动？</p>
<h3 id="判断当前缓存是否过期"><a href="#判断当前缓存是否过期" class="headerlink" title="判断当前缓存是否过期"></a>判断当前缓存是否过期</h3><p>连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件</p>
<h3 id="判断服务器中的文件是否有改动"><a href="#判断服务器中的文件是否有改动" class="headerlink" title="判断服务器中的文件是否有改动"></a>判断服务器中的文件是否有改动</h3><ol>
<li>缓存过期，文件有改动<br>返回200并且带上新的文件。</li>
<li>缓存过期，文件无改动<br>返回一个头信息(304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的<br><strong>过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回304。浏览器认识304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。</strong></li>
</ol>
<h3 id="如何判断缓存的过期以及文件的变动"><a href="#如何判断缓存的过期以及文件的变动" class="headerlink" title="如何判断缓存的过期以及文件的变动"></a>如何判断缓存的过期以及文件的变动</h3><ol>
<li>判断缓存过期<br>主要的方式有两种，这两种都是设定请求头中的某一个字段来实现的：1、Expires；2、Cache-Control。其中Cache-Control设置后优先级比前者高。<br><strong>Cache-control -&gt; max-age字段设定时间</strong></li>
<li>判断文件改动<br>常用的方式为Etag和Last-Modified<br>Last-Modified方式需要用到两个字段：Last-Modified &amp; if-modified-since<br>当第一次请求某一个文件的时候，就会传递回来一个Last-Modified 字段，其内容是这个文件的修改时间。当这个文件缓存过期，浏览器又向服务器请求这个文件的时候，会自动带一个请求头字段If-Modified-Since，其值是上一次传递过来的Last-Modified的值，拿这个值去和服务器中现在这个文件的最后修改时间做对比。</li>
</ol>
<h1 id="cookie-localStorage-sessionStorage"><a href="#cookie-localStorage-sessionStorage" class="headerlink" title="cookie,localStorage,sessionStorage"></a>cookie,localStorage,sessionStorage</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol>
<li>cookie<br>cookie 是存储于访问者的计算机中的变量。每当同一台计算机通过浏览器请求某个页面时，就会发送这个 cookie。你可以使用 JavaScript 来创建和取回 cookie 的值。</li>
<li>sessionStorage<br>​为每一个给定的源（given origin）维持一个独立的存储区域，该存储区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。</li>
<li>localStorage<br>​同样的功能，但是在浏览器关闭，然后重新打开后，除非数据被清除，否则仍然存在。</li>
</ol>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="数据生命期"><a href="#数据生命期" class="headerlink" title="数据生命期"></a>数据生命期</h3><ol>
<li>cookie<br>生成时就会被指定一个maxAge值，这就是cookie的生存周期，在这个周期内cookie有效，默认关闭浏览器失效</li>
<li>sessionStorage<br>页面会话期间可用</li>
<li>localStorage<br>除非数据被清除，否则一直存在</li>
</ol>
<h3 id="存放数据大小"><a href="#存放数据大小" class="headerlink" title="存放数据大小"></a>存放数据大小</h3><ol>
<li>cookie<br>4K左右（因为每次http请求都会携带cookie）    </li>
<li>sessionStorage和localStorage<br>一般5M或更大</li>
</ol>
<h3 id="与服务器通信"><a href="#与服务器通信" class="headerlink" title="与服务器通信"></a>与服务器通信</h3><ol>
<li>cookie<br>由对服务器的请求来传递，每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。    </li>
<li>sessionStorage和localStorage<br>数据不是由每个服务器请求传递的，而是只有在请求时使用数据，不参与和服务器的通信。</li>
</ol>
<h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ol>
<li>cookie<br>cookie需要自己封装setCookie，getCookie。    </li>
<li>sessionStorage和localStorage<br>可以用源生接口，也可再次封装来对Object和Array有更好的支持。</li>
</ol>
<h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>都是保存在浏览器端，和服务器端的session机制不同。</p>
<h2 id="安全性问题"><a href="#安全性问题" class="headerlink" title="安全性问题"></a>安全性问题</h2><p>​无论是cookie还是HTML5的本地存储，都是相对不安全的，很容易受到各种各样的攻击，特别是HTML5的存储空间大，给了攻击者更大的发挥平台，所以都不能用来存储敏感信息。登录信息等重要信息还是存放到服务器里比较好。</p>
<h1 id="session-cookie-token"><a href="#session-cookie-token" class="headerlink" title="session cookie token"></a>session cookie token</h1><h2 id="session-cookie区别"><a href="#session-cookie区别" class="headerlink" title="session cookie区别"></a>session cookie区别</h2><ol>
<li>cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。因此使用cookie只能存储一些小量的数据。</li>
<li>sessionID对cookie有依赖，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，而这个id值在客户端会保存下来，保存的容器就是cookie。</li>
</ol>
<h2 id="session-token"><a href="#session-token" class="headerlink" title="session token"></a>session token</h2><p>浏览器第一次访问服务器时，会传过来一个唯一表示ID，服务端通过算法，加密钥，生成一个token。通过BASE64编码后将token发送给客户端。<br>客户端将token保存起来，下次请求带着token，服务器收到请求会用相同的算法取验证toekn，如果通过就继续执行。</p>
<p>session的存储是需要空间的，session的传输一般都是通过cookie来传输，或url重写的方式。<br>token在服务器时可以不用存储用户信息的，token传递的方式也不限于cookie传递，token也可以保存起来。</p>
<p><strong>session和sessionid：服务器会保存一份，可能保存到缓存/数据库/文件。</strong><br><strong>token：服务器不需要记录任何东西，每次都是一个无状态的请求，每次都是通过解密来验证是否合法。</strong></p>
<h1 id="https"><a href="#https" class="headerlink" title="https"></a>https</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。<br>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL(Secure Sockets Laye)层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。<br><strong>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</strong></p>
<h2 id="与http的区别"><a href="#与http的区别" class="headerlink" title="与http的区别"></a>与http的区别</h2><ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h2 id="具体加密及如何认证"><a href="#具体加密及如何认证" class="headerlink" title="具体加密及如何认证"></a>具体加密及如何认证</h2><blockquote>
<p>证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构 CA 的信息、有效时间、证书序列号等信息的明文，同时包含一个签名；<br>签名的产生算法：首先，使用散列函数计算公开的明文信息的信息摘要，然后，采用 CA 的私钥对信息摘要进行加密，密文即签名；</p>
</blockquote>
<h1 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h1><p>CDN的基本原理是广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求</p>
<h1 id="HTTP2与HTTP1-1"><a href="#HTTP2与HTTP1-1" class="headerlink" title="HTTP2与HTTP1.1"></a>HTTP2与HTTP1.1</h1><ol>
<li>HTTP/2采用二进制格式而非文本格式</li>
<li>HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行</li>
<li>使用报头压缩，HTTP/2降低了开销</li>
<li>HTTP/2让服务器可以将响应主动“推送”到客户端缓存中</li>
</ol>
<h1 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h1><h2 id="websocket与http"><a href="#websocket与http" class="headerlink" title="websocket与http"></a>websocket与http</h2><p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</p>
<p>HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。<br>这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</p>
<h2 id="websocket工作原理"><a href="#websocket工作原理" class="headerlink" title="websocket工作原理"></a>websocket工作原理</h2><p>基于多线程或多进程的服务器无法适用于 WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的 WebSockets 服务器端实现都需要一个异步服务器。</p>
<h2 id="websocket客户端"><a href="#websocket客户端" class="headerlink" title="websocket客户端"></a>websocket客户端</h2><h3 id="websocket属性"><a href="#websocket属性" class="headerlink" title="websocket属性"></a>websocket属性</h3><ol>
<li>Socket.readyState -&gt; 只读属性 readyState 表示连接状态，可以是以下值：0 - 表示连接尚未建立。1 - 表示连接已建立，可以进行通信。2 - 表示连接正在进行关闭。3 - 表示连接已经关闭或者连接不能打开。</li>
<li>Socket.bufferedAmount -&gt; 只读属性 bufferedAmount 已被 send() 放入正在队列中等待传输，但是还没有发出的 UTF-8 文本字节数。</li>
</ol>
<h3 id="websocket事件"><a href="#websocket事件" class="headerlink" title="websocket事件"></a>websocket事件</h3><ol>
<li>open -&gt; 连接建立时触发</li>
<li>message -&gt; 客户端接收服务端数据时触发</li>
<li>error -&gt; 通信发生错误时触发</li>
<li>close -&gt; 连接关闭时触发</li>
</ol>
<h3 id="websocket方法"><a href="#websocket方法" class="headerlink" title="websocket方法"></a>websocket方法</h3><ol>
<li>Socket.send()</li>
<li>Socket.close()</li>
</ol>
<h2 id="websocket服务端"><a href="#websocket服务端" class="headerlink" title="websocket服务端"></a>websocket服务端</h2><p>Socket.io</p>
<h1 id="tcp三次握手四次挥手"><a href="#tcp三次握手四次挥手" class="headerlink" title="tcp三次握手四次挥手"></a>tcp三次握手四次挥手</h1><h2 id="三次握手、四次挥手过程"><a href="#三次握手、四次挥手过程" class="headerlink" title="三次握手、四次挥手过程"></a>三次握手、四次挥手过程</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。</p>
<ol>
<li>第一次握手：建立连接时，客户端A发送SYN包(SYN=j)到服务器B，并进入SYN_SEND状态，等待服务器B确认。</li>
<li>第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK=j+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器B进入SYN_RECV状态。</li>
<li>第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK(ACK=k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。</li>
<li>完成三次握手，客户端与服务器开始传送数据。</li>
</ol>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<ol>
<li>客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送(报文段4)。</li>
<li>服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号。</li>
<li>服务器B关闭与客户端A的连接，发送一个FIN给客户端A(报文段6)。</li>
<li>客户端A发回ACK报文确认，并将确认序号设置为收到序号加1(报文段7)。</li>
</ol>
<h1 id="RESTful架构"><a href="#RESTful架构" class="headerlink" title="RESTful架构"></a>RESTful架构</h1><h1 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h1><ol>
<li>正向代理中，proxy和client同属一个LAN，对server透明；</li>
<li>反向代理中，proxy和server同属一个LAN，对client透明。</li>
</ol>

                <hr>
                

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/2018/11/07/vue-sourceCode/" data-toggle="tooltip" data-placement="top"
                           title="Vue源码学习（1）">&larr; Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/2018/10/31/interview-css/" data-toggle="tooltip" data-placement="top"
                           title="常见面试问题总结（css）">Next Post &rarr;</a>
                    </li>
                    
                </ul>

                

                


                <!--加入新的评论系统-->
                

                

            </div>

            <div class="hidden-xs col-sm-3 toc-col">
                <div class="toc-wrap">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#http请求"><span class="toc-text">http请求</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#从输入一个url到返回数据，发生了什么"><span class="toc-text">从输入一个url到返回数据，发生了什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器获得资源后到呈现页面的过程"><span class="toc-text">浏览器获得资源后到呈现页面的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS过程"><span class="toc-text">DNS过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http特性"><span class="toc-text">http特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http请求方法"><span class="toc-text">http请求方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET"><span class="toc-text">GET</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POST"><span class="toc-text">POST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-POST对比"><span class="toc-text">GET POST对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HEAD"><span class="toc-text">HEAD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http请求的header"><span class="toc-text">http请求的header</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache"><span class="toc-text">Cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client"><span class="toc-text">Client</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-Login"><span class="toc-text">Cookie/Login</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Entity"><span class="toc-text">Entity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Miscellaneous"><span class="toc-text">Miscellaneous</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Transport"><span class="toc-text">Transport</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应的状态码"><span class="toc-text">响应的状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缓存与304"><span class="toc-text">缓存与304</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#判断当前缓存是否过期"><span class="toc-text">判断当前缓存是否过期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#判断服务器中的文件是否有改动"><span class="toc-text">判断服务器中的文件是否有改动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何判断缓存的过期以及文件的变动"><span class="toc-text">如何判断缓存的过期以及文件的变动</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie-localStorage-sessionStorage"><span class="toc-text">cookie,localStorage,sessionStorage</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#区别"><span class="toc-text">区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据生命期"><span class="toc-text">数据生命期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存放数据大小"><span class="toc-text">存放数据大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与服务器通信"><span class="toc-text">与服务器通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#易用性"><span class="toc-text">易用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#共同点"><span class="toc-text">共同点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安全性问题"><span class="toc-text">安全性问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#session-cookie-token"><span class="toc-text">session cookie token</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#session-cookie区别"><span class="toc-text">session cookie区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#session-token"><span class="toc-text">session token</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#https"><span class="toc-text">https</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本概念-1"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与http的区别"><span class="toc-text">与http的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#具体加密及如何认证"><span class="toc-text">具体加密及如何认证</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CDN"><span class="toc-text">CDN</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP2与HTTP1-1"><span class="toc-text">HTTP2与HTTP1.1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#websocket"><span class="toc-text">websocket</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket与http"><span class="toc-text">websocket与http</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket工作原理"><span class="toc-text">websocket工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket客户端"><span class="toc-text">websocket客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket属性"><span class="toc-text">websocket属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket事件"><span class="toc-text">websocket事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket方法"><span class="toc-text">websocket方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#websocket服务端"><span class="toc-text">websocket服务端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tcp三次握手四次挥手"><span class="toc-text">tcp三次握手四次挥手</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#三次握手、四次挥手过程"><span class="toc-text">三次握手、四次挥手过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#三次握手"><span class="toc-text">三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四次挥手"><span class="toc-text">四次挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RESTful架构"><span class="toc-text">RESTful架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正向代理和反向代理"><span class="toc-text">正向代理和反向代理</span></a></li></ol>
                </div>
            </div>
        </div>

        <div class="row">
            <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5 class="text-center">
                        <a href="/tags/">FEATURED TAGS</a>
                    </h5>
                    <div class="tags">
                        
                        <a class="tag" href="/tags/#Vue"
                           title="Vue">Vue</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>
        </div>

    </div>
</article>







<!-- Footer -->
<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 text-center">
                <br>
                <ul class="list-inline text-center">
                
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhaoangus">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/zhaoangus">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Angus 2019
                    <br>
                    <span id="busuanzi_container_site_pv" style="font-size: 12px;">PV: <span id="busuanzi_value_site_pv"></span> Times</span>
                    <br>
                    Theme by <a href="https://haojen.github.io/">Haojen Ma</a>
                </p>

            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/blog.js"></script>

<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://zhaoangus.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>

<!-- Google Analytics -->



<!-- Baidu Tongji -->


<!-- swiftype -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','','2.0.0');
</script>

<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!--wechat title img-->
<img class="wechat-title-img" src="/images/avatar.png">
</body>

</html>
